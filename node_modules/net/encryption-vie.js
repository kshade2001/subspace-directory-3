/*
    Subspace Directory 3
    Copyright (C) 2015 Kingsley Masters
    Email: kingsley at flabbyfish.co.uk

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* Javascript Port of Subspace II Vie Encrypion
   based on code from ASSS project http://asss.yi.org 
   Also using code from MERVBOT by catid 
*/

/*jslint node: true */
"use strict";

require("buffer");
var crypto = require("crypto");
var HeavyLcg = require("net/heavy-lcg");

var EncryptionVie = function (isContinuum) {
   this._flag = isContinuum ? 0x11:0x01;
   this._key = -1;
   this._keyStream = new Buffer(520);
   this._heavyLcg = new HeavyLcg();
   
   this.initEncryptionTable = function() {
        var k = this._key;
        if (k == 0)
            return;
        this._heavyLcg.seed(k);
        for(var i =0; i< this._keyStream.length; i=i+2)
        {
            this._keyStream.writeUInt16LE(this._heavyLcg.getNextEncryption(),i);
        }
   }.bind(this);
};

EncryptionVie.prototype.login = function () {
    var buf = crypto.randomBytes(4);
    this._key = buf.readInt32LE(0);
    //key must be negative
    if ( this._key > 0) {
        this._key = - this._key;
    }
    var loginRequest = new Buffer([0x00,0x01,0x00,0x00,0x00,0x00,this._flag,0x00]); 
    loginRequest.writeUInt32LE(this._key,2, true);
    return loginRequest;
};

EncryptionVie.prototype.reply = function (loginRequestBuffer) {
    this._key = -loginRequestBuffer.readInt32LE(2);
    var loginReply = new Buffer([0x00,0x02,0x00,0x00,0x00,0x00]);
    loginReply.writeUInt32LE(this._key,2);
    this.initEncryptionTable();
    return loginReply;
};

EncryptionVie.prototype.encrypt = function (message) {
    if (message.length > 520) 
        throw "Max Packet Length for VIE Encrption is 520";

    var work = this._key;

    var mydata = 0;

    var loop, until;

    if (work == 0 || this._keyStream.readInt32LE(0) == 0)
        return;

    if (message[0] == 0)
    {
        mydata = 2;
        until = (message.length - 2) / 4 + 1;
    }
    else
    {
        mydata = 1;
        until = (message.length - 1) / 4 + 1;
    }

    for (loop = 0; loop < until; loop++)
    {
        work = message.readInt32LE(mydata + loop * 4,true) ^
            this._keyStream.readInt32LE(loop * 4) ^ work;                   

        message.writeUInt32LE(work, mydata + loop * 4, true);
    }

    return message;
};

EncryptionVie.prototype.decrypt = function (message) {
    if (message.length > 520) 
        throw "Max Packet Length for VIE Encrption is 520";
    var work = this._key;

    var mydata = 0;
    var loop, until;

    if (work == 0 || this._keyStream.readInt32LE(0) == 0)
        return;

    if (message[0] == 0)
    {
        mydata = 2;
        until = (message.length - 2) / 4 + 1;
    }
    else
    {
        mydata = 1;
        until = (message.length - 1) / 4 + 1;
    }

    for (loop = 0; loop < until; loop++)
    {
        var tmp = message.readInt32LE(mydata + loop * 4, true);
        
        message.writeInt32LE(this._keyStream.readInt32LE(loop * 4) ^ work ^ tmp, mydata + loop * 4, true);

        work = tmp;               
    }
    return message;
};


module.exports = EncryptionVie;